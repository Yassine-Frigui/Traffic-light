\documentclass[12pt,a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{tabularray}
\usepackage{float}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{caption}

% Geometry
\geometry{left=2.5cm, right=2.5cm, top=2.5cm, bottom=2.5cm}

% Colors
\definecolor{primaryblue}{RGB}{0, 102, 204}
\definecolor{darkgray}{RGB}{64, 64, 64}
\definecolor{lightgray}{RGB}{240, 240, 240}
\definecolor{codegreen}{RGB}{0, 128, 0}
\definecolor{codepurple}{RGB}{128, 0, 128}

% Hyperref setup
\hypersetup{
    colorlinks=true,
    linkcolor=primaryblue,
    urlcolor=primaryblue,
    citecolor=primaryblue
}

% Code listings style
\lstset{
    basicstyle=\ttfamily\small,
    keywordstyle=\color{primaryblue}\bfseries,
    commentstyle=\color{codegreen},
    stringstyle=\color{codepurple},
    backgroundcolor=\color{lightgray},
    frame=single,
    breaklines=true,
    numbers=left,
    numberstyle=\tiny\color{darkgray}
}

% Chapter title formatting
\titleformat{\chapter}[display]
{\normalfont\huge\bfseries\color{primaryblue}}
{\chaptertitlename\ \thechapter}{20pt}{\Huge}

% Section formatting
\titleformat{\section}
{\normalfont\Large\bfseries\color{primaryblue}}
{\thesection}{1em}{}

\titleformat{\subsection}
{\normalfont\large\bfseries\color{darkgray}}
{\thesubsection}{1em}{}

% Header and footer
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\leftmark}
\fancyhead[R]{\thepage}
\fancyfoot[C]{Projet Semestriel - Simulation de Feux de Circulation}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

%===============================================================================
% DOCUMENT
%===============================================================================

\begin{document}

%-------------------------------------------------------------------------------
% PAGE DE GARDE
%-------------------------------------------------------------------------------
\begin{titlepage}
    \centering
    
    % Espace pour logo de l'université/école
    \vspace*{1cm}
    
    % ============================================
    % ESPACE POUR LOGO UNIVERSITÉ / ÉCOLE
    % ============================================
    \begin{center}
        %\includegraphics[width=6cm]{images/logo_universite.png}
        \fbox{\parbox{6cm}{\centering\vspace{2cm}\textbf{LOGO UNIVERSITÉ}\vspace{2cm}}}
    \end{center}
    
    \vspace{1cm}
    
    {\Large\textbf{RAPPORT DE PROJET SEMESTRIEL}}
    
    \vspace{0.5cm}
    
    {\large Année Universitaire 2025-2026}
    
    \vspace{2cm}
    
    {\Huge\textbf{\color{primaryblue}Système de Simulation\\de Feux de Circulation}}
    
    \vspace{0.5cm}
    
    {\Large\textit{Visualisation 3D en Temps Réel}}
    
    \vspace{2cm}
    
    % ============================================
    % ESPACE POUR LOGO DU PROJET
    % ============================================
    \begin{center}
        %\includegraphics[width=4cm]{images/logo_projet.png}
        \fbox{\parbox{4cm}{\centering\vspace{1.5cm}\textbf{LOGO PROJET}\vspace{1.5cm}}}
    \end{center}
    
    \vspace{2cm}
    
    \begin{tabular}{rl}
        \textbf{Réalisé par :} & Yassine Frigui \\
                               & [Nom du Binôme] \\
        \textbf{Encadré par :} & [Nom de l'encadrant] \\
        \textbf{Filière :} & [Nom de la filière] \\
        \textbf{Date :} & Janvier 2026 \\
    \end{tabular}
    
    \vfill
    
    % ============================================
    % ESPACE POUR LOGO ENTREPRISE / ORGANISME
    % ============================================
    \begin{center}
        %\includegraphics[width=4cm]{images/logo_entreprise.png}
        \fbox{\parbox{4cm}{\centering\vspace{1cm}\textbf{LOGO ORGANISME}\vspace{1cm}}}
    \end{center}
    
\end{titlepage}

%-------------------------------------------------------------------------------
% TABLE DES MATIÈRES
%-------------------------------------------------------------------------------
\tableofcontents
\newpage

%===============================================================================
% INTRODUCTION GÉNÉRALE
%===============================================================================
\chapter*{Introduction Générale}
\addcontentsline{toc}{chapter}{Introduction Générale}

Ce rapport présente le travail réalisé par notre binôme dans le cadre du projet semestriel de l'année universitaire 2025-2026 à \textbf{[Nom de l'Université]}. Ce projet s'inscrit dans le module \textbf{[Nom du Module]}, enseigné par \textbf{[Nom du Professeur]}, et vise à mettre en pratique les compétences acquises en développement logiciel, architecture système, et déploiement d'applications web.

Le domaine de la simulation de trafic routier constitue un enjeu majeur pour la planification urbaine moderne. Les systèmes de gestion du trafic permettent d'optimiser la circulation, de réduire les embouteillages, et d'améliorer la sécurité routière. Dans ce contexte, ce projet propose le développement d'un système complet de simulation de feux de circulation avec visualisation 3D en temps réel.

L'objectif principal de ce projet est de concevoir et implémenter une application web distribuée permettant de simuler le comportement d'une intersection routière contrôlée par des feux tricolores. Le système doit offrir une expérience utilisateur immersive grâce à un rendu 3D interactif, tout en garantissant une architecture robuste, sécurisée et déployable en environnement de production.

Ce travail s'articule autour de trois axes principaux :

\textbf{L'analyse et la conception :} Cette phase comprend l'étude des solutions existantes dans le domaine de la simulation de trafic, l'identification de leurs limitations, et la proposition d'une architecture adaptée aux besoins identifiés. L'analyse des besoins fonctionnels et non fonctionnels permet de définir précisément les fonctionnalités à implémenter et les contraintes techniques à respecter.

\textbf{Le développement et l'implémentation :} Le système repose sur une architecture client-serveur moderne, séparant le backend de simulation (Python avec aiohttp) du frontend de visualisation (React avec Three.js). Cette séparation permet une maintenance facilitée et une évolutivité optimale. L'implémentation intègre des mécanismes de communication temps réel via WebSocket, une physique réaliste des véhicules, et des mesures de sécurité pour un déploiement en production.

\textbf{Le déploiement et la validation :} Le système est déployé sur des plateformes cloud professionnelles (Netlify pour le frontend, Render pour le backend), avec un workflow CI/CD automatisé via GitHub Actions. Des tests fonctionnels, de performance et de sécurité valident la conformité du système aux spécifications.

Ce rapport est organisé en trois chapitres principaux. Le premier chapitre présente le contexte du projet, l'analyse des solutions existantes, et les objectifs visés. Le deuxième chapitre détaille la phase de planification, incluant l'analyse des besoins et la définition de l'environnement de travail. Le troisième chapitre décrit l'implémentation technique, l'architecture détaillée, et le déploiement du système. Enfin, une conclusion générale synthétise les réalisations et propose des perspectives d'évolution.

\newpage

%===============================================================================
% CHAPITRE 1 : INTRODUCTION
%===============================================================================
\chapter{Introduction}

Ce chapitre présente le cadre général du projet, incluant le contexte institutionnel, l'étude des solutions existantes dans le domaine de la simulation de trafic, et la présentation de la solution développée. Il permet de comprendre les motivations du projet et les choix technologiques effectués.

\section{Organisme d'Accueil}

Cette section présente le cadre institutionnel et pédagogique dans lequel s'inscrit ce projet semestriel.

% ============================================
% ESPACE POUR LOGO DE L'ORGANISME
% ============================================
\begin{figure}[H]
    \centering
    %\includegraphics[width=5cm]{images/logo_organisme.png}
    \fbox{\parbox{5cm}{\centering\vspace{2cm}\textbf{LOGO ORGANISME D'ACCUEIL}\vspace{2cm}}}
    \caption{Logo de l'organisme d'accueil}
\end{figure}

Ce projet semestriel a été réalisé dans le cadre de notre formation académique à \textbf{[Nom de l'Université]}, au sein de la filière \textbf{[Nom de la Filière]}. Le projet s'inscrit dans le module \textbf{[Nom du Module]}, enseigné par \textbf{[Nom du Professeur]}, dont l'objectif est de mettre en pratique les compétences acquises en développement web, programmation système, et conception d'architectures logicielles distribuées.

L'objectif principal de ce travail en binôme était de concevoir et développer un système complet de simulation de feux de circulation, permettant d'appliquer concrètement les connaissances théoriques à un cas d'usage réel : la modélisation du trafic routier et la gestion intelligente des intersections. Ce projet représente une opportunité d'approfondir les compétences en développement full-stack, communication temps réel, et déploiement cloud.

Le projet s'inscrit dans une démarche d'apprentissage pratique, favorisant l'autonomie, la recherche de solutions techniques, et la mise en œuvre de bonnes pratiques professionnelles en ingénierie logicielle.

\subsection{Contexte du Projet}

La simulation de trafic est un domaine essentiel dans la planification urbaine moderne. Ce projet vise à créer une plateforme éducative et démonstrative permettant de visualiser en temps réel le comportement des véhicules aux intersections régulées par des feux de signalisation.

\subsection{Objectifs Pédagogiques}

Ce projet en binôme vise à développer les compétences suivantes :

\begin{itemize}
    \item Maîtriser le développement full-stack (frontend et backend) en équipe
    \item Implémenter une communication temps réel via WebSocket
    \item Concevoir une architecture logicielle modulaire et maintenable
    \item Appliquer les bonnes pratiques de sécurité informatique
    \item Déployer une application en environnement de production
    \item Collaborer efficacement sur un projet technique complexe
\end{itemize}

%-------------------------------------------------------------------------------
\section{Étude et Analyse}

Avant de concevoir la solution, une étude approfondie des systèmes de simulation de trafic existants a été menée. Cette analyse comparative permet d'identifier les meilleures pratiques du domaine, les limitations des solutions actuelles, et les opportunités d'innovation pour ce projet.

\subsection{Étude de l'Existant}

Le domaine de la simulation de trafic dispose de plusieurs solutions existantes, allant des outils professionnels aux projets académiques. Une analyse des principales solutions du marché a été effectuée pour identifier les meilleures pratiques et les fonctionnalités essentielles.

\subsubsection{SUMO (Simulation of Urban MObility)}

SUMO est un simulateur de trafic microscopique, open source, développé par le Centre Aérospatial Allemand (DLR). Il s'agit de l'un des outils les plus utilisés dans la recherche académique et l'industrie.

\textbf{Caractéristiques principales :}
\begin{itemize}
    \item Simulation microscopique et continue du trafic
    \item Support de réseaux routiers de grande échelle
    \item Simulation intermodale (véhicules, piétons, transports publics)
    \item Interface de contrôle en temps réel (TraCI)
    \item Import de données OpenStreetMap
    \item Modélisation des feux de circulation avec optimisation temporelle
\end{itemize}

\subsubsection{AnyLogic Road Traffic Library}

AnyLogic est une plateforme de simulation multi-méthodes commerciale offrant une bibliothèque spécialisée pour le trafic routier.

\textbf{Caractéristiques principales :}
\begin{itemize}
    \item Modélisation basée sur les agents
    \item Visualisation 3D avancée
    \item Optimisation du séquencement des feux de circulation
    \item Analyse de débit et détection des embouteillages
    \item Intégration avec des bâtiments et infrastructures publiques
    \item Cartes de densité pour visualiser la congestion
\end{itemize}

\subsubsection{PTV Vissim}

Vissim est un logiciel commercial de microsimulation du trafic largement utilisé par les professionnels de l'urbanisme.

\textbf{Caractéristiques principales :}
\begin{itemize}
    \item Haute fidélité dans la modélisation du comportement des conducteurs
    \item Analyse des délais et niveaux de service
    \item Simulation de différents modes de transport
    \item Intégration avec les systèmes de contrôle du trafic
\end{itemize}

\subsubsection{Simulateurs Web Éducatifs}

Plusieurs projets web proposent des simulations simplifiées à des fins éducatives, utilisant généralement des technologies comme JavaScript, Canvas, ou WebGL pour la visualisation.

\subsection{Critique de l'Existant}

L'analyse des solutions existantes révèle plusieurs limitations qui ont motivé le développement de ce projet :

\begin{table}[H]
\centering
\caption{Analyse critique des solutions existantes}
\begin{tblr}{
    colspec = {|X[1.5]|X[2]|X[2]|},
    hlines,
    row{1} = {bg=primaryblue, fg=white, font=\bfseries},
}
Solution & Points Forts & Limitations \\
SUMO & Open source, très complet, grande communauté & Interface utilisateur complexe, courbe d'apprentissage élevée, pas de visualisation 3D native \\
AnyLogic & Visualisation 3D, multi-méthodes & Licence coûteuse, pas accessible pour l'éducation \\
PTV Vissim & Précision industrielle & Coût très élevé, complexité excessive pour des projets simples \\
Simulateurs Web & Accessibles, légers & Fonctionnalités limitées, pas de communication temps réel \\
\end{tblr}
\end{table}

\textbf{Limitations communes identifiées :}
\begin{enumerate}
    \item \textbf{Accessibilité} : Les outils professionnels sont coûteux ou complexes à maîtriser
    \item \textbf{Visualisation temps réel} : Peu de solutions offrent une visualisation 3D interactive dans le navigateur
    \item \textbf{Architecture client-serveur} : Les simulateurs web existants sont souvent purement côté client, sans synchronisation serveur
    \item \textbf{Personnalisation} : Difficulté à modifier les scénarios (conditions météo, événements)
    \item \textbf{Déploiement} : Complexité d'installation et de configuration
\end{enumerate}

\subsection{Solution Proposée}

Face aux limitations identifiées, nous avons conçu une solution qui répond aux besoins suivants :

\begin{itemize}
    \item \textbf{Accessibilité} : Application web fonctionnant directement dans le navigateur, sans installation
    \item \textbf{Visualisation 3D temps réel} : Utilisation de Three.js pour un rendu 3D fluide et interactif
    \item \textbf{Architecture distribuée} : Séparation claire entre le serveur de simulation (Python) et le client de visualisation (React)
    \item \textbf{Communication temps réel} : Protocole WebSocket pour des mises à jour instantanées
    \item \textbf{Modularité} : Code organisé en modules pour faciliter la maintenance et l'évolution
    \item \textbf{Sécurité} : Validation des origines, limitation du débit, gestion des connexions
    \item \textbf{Multi-environnements} : Plusieurs cartes thématiques (pluie, désert, neige, ville)
    \item \textbf{Événements dynamiques} : Simulation d'heures de pointe, accidents, conditions météo
\end{itemize}

%-------------------------------------------------------------------------------
\section{Présentation Générale}

Cette section décrit de manière détaillée le système développé, ses fonctionnalités principales, son architecture globale, et les technologies mises en œuvre pour garantir une expérience utilisateur optimale.

Ce projet, réalisé dans le cadre d'un \textbf{projet semestriel}, constitue une application complète de simulation de feux de circulation avec visualisation 3D en temps réel. Le système simule une intersection routière contrôlée par des feux de signalisation tricolores, offrant une expérience immersive et interactive.

L'application permet de visualiser en temps réel le comportement des véhicules aux intersections, en respectant les règles de circulation routière. Des véhicules sont générés dynamiquement et circulent selon des règles strictes : respect des feux de signalisation (arrêt au rouge, passage au vert), gestion intelligente des virages (gauche, droite, tout droit), maintien des distances de sécurité entre véhicules, et détection automatique des collisions.

Le projet adopte une architecture distribuée moderne, séparant clairement le serveur de simulation (backend Python) et le client de visualisation (frontend React). Cette séparation permet une scalabilité optimale et une maintenance facilitée. Le backend, hébergé sur Render.com, génère l'état du trafic et gère la logique métier, tandis que le frontend, déployé sur Netlify, assure le rendu 3D via Three.js et l'interface utilisateur.

La communication entre les deux composants s'effectue via WebSocket, garantissant des mises à jour en temps réel avec une latence minimale. Cette architecture permet de supporter plusieurs clients simultanés, chacun visualisant la même simulation synchronisée. Le système intègre également un mécanisme de maintien actif via GitHub Actions, assurant la disponibilité continue du serveur backend.

L'application propose cinq environnements thématiques différents (intersection simple, pluie, désert, neige, grille urbaine), permettant de simuler diverses conditions météorologiques et urbanistiques. Un système d'événements dynamiques enrichit la simulation avec des scénarios réalistes tels que les heures de pointe, les accidents, ou les travaux de construction, modifiant le flux de trafic en conséquence.

%-------------------------------------------------------------------------------
\section{Conclusion du Chapitre}

Ce premier chapitre a permis d'établir le contexte institutionnel et technique du projet. L'analyse des solutions existantes dans le domaine de la simulation de trafic a révélé plusieurs limitations majeures : complexité d'utilisation, coûts élevés, absence de visualisation 3D interactive accessible, et difficultés de déploiement.

Face à ces constats, notre équipe a proposé une solution originale, combinant accessibilité web (aucune installation requise), visualisation 3D immersive via Three.js, architecture distribuée moderne (séparation client-serveur), et communication temps réel via WebSocket. Cette approche répond aux besoins identifiés tout en offrant une expérience utilisateur fluide et interactive.

La présentation générale du système a permis de comprendre les fonctionnalités principales : simulation réaliste des feux de circulation, génération dynamique de véhicules, physique des trajectoires, système d'événements, et interface de contrôle intuitive. Le système s'appuie sur un stack technologique moderne et éprouvé, garantissant performance, sécurité et maintenabilité.

Le chapitre suivant détaillera la phase de planification, incluant l'analyse détaillée des besoins fonctionnels et non fonctionnels, l'identification des acteurs, la définition de l'environnement de travail, et la conception de l'architecture globale du système.

%===============================================================================
% CHAPITRE 2 : PLANIFICATION
%===============================================================================
\chapter{Planification}

\section{Analyse des Besoins}

L'analyse des besoins constitue une étape fondamentale dans la conception du système. Elle permet d'identifier les différents acteurs du projet, de définir précisément les fonctionnalités attendues (besoins fonctionnels), et d'établir les contraintes de qualité à respecter (besoins non fonctionnels). Cette phase garantit que le système développé répondra aux attentes et aux exigences techniques du projet.

\subsection{Identification des Acteurs}

Le système implique plusieurs acteurs qui interagissent de manière différente avec l'application :

\textbf{Utilisateur Final :} Il s'agit de toute personne accédant à l'application via un navigateur web. L'utilisateur peut observer la simulation en temps réel, contrôler la caméra 3D, mettre en pause la simulation, changer d'environnement de carte, et observer les statistiques de trafic.

\textbf{Serveur de Simulation :} Composant backend qui génère automatiquement l'état du trafic, contrôle les cycles des feux de circulation, crée les véhicules, et diffuse les mises à jour aux clients connectés.

\textbf{Client Web :} Application React s'exécutant dans le navigateur de l'utilisateur. Elle reçoit les données du serveur, effectue le rendu 3D de la scène, et gère les interactions utilisateur.

\textbf{Administrateur :} Personne responsable de la configuration, du déploiement et de la maintenance du système sur les plateformes d'hébergement.

% ============================================
% ESPACE POUR DIAGRAMME DE CAS D'UTILISATION
% ============================================
\begin{figure}[H]
    \centering
    %\includegraphics[width=12cm]{diagrams/use_case_diagram.png}
    \fbox{\parbox{12cm}{\centering\vspace{4cm}\textbf{DIAGRAMME DE CAS D'UTILISATION}\vspace{4cm}}}
    \caption{Diagramme de cas d'utilisation du système}
\end{figure}

\subsection{Besoins Fonctionnels}

Les besoins fonctionnels décrivent les fonctionnalités essentielles que le système doit fournir. Le tableau suivant présente les sept besoins fonctionnels identifiés avec leurs descriptions détaillées :

\begin{table}[H]
\centering
\caption{Besoins fonctionnels du système}
\begin{tblr}{
    colspec = {|l|X[3]|},
    hlines,
    row{1} = {bg=primaryblue, fg=white, font=\bfseries},
    rowsep = 3pt,
}
Identifiant & Description \\
\textbf{BF01} & \textbf{Visualisation 3D de l'intersection :} Le système doit afficher une intersection routière complète en 3D avec feux de circulation, routes texturées, véhicules animés, et environnements thématiques (pluie, désert, neige, ville). \\
\textbf{BF02} & \textbf{Simulation des feux de circulation :} Le système doit gérer le cycle complet des feux (VERT → JAUNE → ROUGE) avec synchronisation Nord/Sud et Est/Ouest, minuteries visuelles sur chaque feu, et coordination temporelle réaliste. \\
\textbf{BF03} & \textbf{Génération et physique des véhicules :} Le système doit générer dynamiquement des véhicules avec vitesses variables, gérer les trajectoires de virages réalistes via machine à états, assurer le respect des feux de circulation, et maintenir les distances de sécurité. \\
\textbf{BF04} & \textbf{Système d'événements dynamiques :} Le système doit simuler différents scénarios de trafic (heure de pointe, accident, mauvais temps, construction) modifiant le flux de véhicules, avec affichage de l'événement actif dans l'interface. \\
\textbf{BF05} & \textbf{Interface de contrôle utilisateur :} L'utilisateur doit pouvoir contrôler la caméra 3D (rotation, zoom), mettre en pause/reprendre la simulation, changer d'environnement de carte, et consulter les statistiques (collisions, connexion). \\
\textbf{BF06} & \textbf{Communication temps réel :} Le système doit maintenir une connexion WebSocket bidirectionnelle avec le serveur, recevoir les mises à jour d'état en temps réel, gérer la reconnexion automatique, et afficher le statut de connexion. \\
\textbf{BF07} & \textbf{Détection et comptage des collisions :} Le système doit détecter les collisions entre véhicules, incrémenter un compteur visible dans l'interface, et permettre le suivi des incidents durant la simulation. \\
\end{tblr}
\end{table}

\subsection{Besoins Non Fonctionnels}

\subsubsection{Performance}

Le système doit garantir un rendu fluide à 60 FPS minimum avec une latence réseau maximale de 200ms. Au-delà, l'interpolation côté client assure une dégradation gracieuse de l'expérience utilisateur.

\subsubsection{Sécurité}

Validation stricte des origines WebSocket pour n'accepter que les domaines autorisés, limitation du débit à 10 connexions/minute/IP, et restriction de la taille des messages à 1 Ko pour prévenir les attaques DoS.

\subsubsection{Fiabilité}

Support de 100 clients simultanés sans dégradation, mécanisme de heartbeat (ping/30s) pour nettoyer les connexions mortes, et reconnexion automatique côté client pour assurer la continuité du service.

\subsubsection{Maintenabilité}

Architecture modulaire avec séparation claire des responsabilités (métier, réseau, rendu) facilitant la maintenance. Centralisation des constantes permettant d'ajuster le comportement sans modifier la logique métier.

\subsubsection{Portabilité}

Compatibilité avec tous les navigateurs modernes supportant WebGL (Chrome, Firefox, Edge, Safari) sans installation requise. Application web accessible depuis n'importe quel appareil avec navigateur compatible.

%-------------------------------------------------------------------------------
\section{Environnement de Travail}

Cette section présente l'ensemble des outils, technologies et plateformes utilisés pour le développement, le test et le déploiement du système. Le choix d'un environnement de travail moderne et adapté est essentiel pour garantir la productivité, la qualité du code, et la facilité de maintenance du projet.

\subsection{Environnement de Développement}

L'environnement de développement regroupe les outils utilisés quotidiennement pour l'édition du code, le contrôle de version, et la gestion du projet.

\textbf{Visual Studio Code}

% LOGO VS CODE
\begin{figure}[H]
    \centering
    %\includegraphics[width=3cm]{images/vscode_logo.png}
    \fbox{\parbox{3cm}{\centering\vspace{1cm}\textbf{LOGO VS CODE}\vspace{1cm}}}
\end{figure}

Visual Studio Code est un éditeur de code source léger mais puissant, développé par Microsoft. Il offre un support natif pour JavaScript, Python, et de nombreux autres langages via des extensions. Son intégration Git, son débogueur intégré, et son terminal font de VS Code l'outil idéal pour le développement full-stack.

\vspace{0.5cm}

\textbf{GitHub}

% LOGO GITHUB
\begin{figure}[H]
    \centering
    %\includegraphics[width=3cm]{images/github_logo.png}
    \fbox{\parbox{3cm}{\centering\vspace{1cm}\textbf{LOGO GITHUB}\vspace{1cm}}}
\end{figure}

GitHub est une plateforme de gestion de versions basée sur Git, facilitant la collaboration et le suivi de l'historique du code. Elle permet le déploiement automatique via GitHub Actions, l'hébergement du code source, et la gestion des workflows CI/CD pour maintenir le serveur backend actif.

\subsection{Technologies Utilisées}

Le stack technologique a été soigneusement sélectionné pour garantir performance, maintenabilité et compatibilité avec les standards modernes du développement web.

\subsubsection{Frontend}

Le frontend repose sur des technologies JavaScript modernes permettant de créer une interface utilisateur réactive et un rendu 3D performant.

\textbf{Node.js 20}

% LOGO NODE.JS
\begin{figure}[H]
    \centering
    %\includegraphics[width=3cm]{images/nodejs_logo.png}
    \fbox{\parbox{3cm}{\centering\vspace{1cm}\textbf{LOGO NODE.JS}\vspace{1cm}}}
\end{figure}

Node.js est un environnement d'exécution JavaScript côté serveur, nécessaire pour exécuter les outils de build modernes. Il permet d'utiliser npm (Node Package Manager) pour gérer les dépendances du projet frontend et exécuter les scripts de développement.

\vspace{0.5cm}

\textbf{React 18}

% LOGO REACT
\begin{figure}[H]
    \centering
    %\includegraphics[width=3cm]{images/react_logo.png}
    \fbox{\parbox{3cm}{\centering\vspace{1cm}\textbf{LOGO REACT}\vspace{1cm}}}
\end{figure}

React est une bibliothèque JavaScript développée par Meta pour construire des interfaces utilisateur. Elle utilise un paradigme déclaratif basé sur les composants, facilitant la création d'UI interactives et réactives.

\vspace{0.5cm}

\textbf{Three.js r160}

% LOGO THREE.JS
\begin{figure}[H]
    \centering
    %\includegraphics[width=3cm]{images/threejs_logo.png}
    \fbox{\parbox{3cm}{\centering\vspace{1cm}\textbf{LOGO THREE.JS}\vspace{1cm}}}
\end{figure}

Three.js est une bibliothèque JavaScript de rendu 3D utilisant WebGL. Elle simplifie la création de scènes 3D complexes avec caméras, lumières, matériaux et animations, directement dans le navigateur.

\vspace{0.5cm}

\textbf{Vite 5}

% LOGO VITE
\begin{figure}[H]
    \centering
    %\includegraphics[width=3cm]{images/vite_logo.png}
    \fbox{\parbox{3cm}{\centering\vspace{1cm}\textbf{LOGO VITE}\vspace{1cm}}}
\end{figure}

Vite est un outil de build moderne offrant un serveur de développement ultra-rapide grâce au rechargement à chaud (HMR) et un bundler optimisé pour la production.

\subsubsection{Backend}

Le backend utilise Python et ses bibliothèques modernes pour assurer une communication asynchrone performante et une gestion optimale des connexions simultanées.

\textbf{Python 3.12}

% LOGO PYTHON
\begin{figure}[H]
    \centering
    %\includegraphics[width=3cm]{images/python_logo.png}
    \fbox{\parbox{3cm}{\centering\vspace{1cm}\textbf{LOGO PYTHON}\vspace{1cm}}}
\end{figure}

Python est un langage de programmation polyvalent, réputé pour sa syntaxe claire et sa riche bibliothèque standard. Il est idéal pour le développement rapide d'applications serveur.

\vspace{0.5cm}

\textbf{aiohttp 3.9}

% LOGO AIOHTTP
\begin{figure}[H]
    \centering
    %\includegraphics[width=3cm]{images/aiohttp_logo.png}
    \fbox{\parbox{3cm}{\centering\vspace{1cm}\textbf{LOGO AIOHTTP}\vspace{1cm}}}
\end{figure}

aiohttp est un framework HTTP/WebSocket asynchrone pour Python. Il permet de gérer efficacement de nombreuses connexions simultanées grâce à la programmation async/await.

\subsection{Hébergement et Déploiement}

Le déploiement du système repose sur des plateformes cloud modernes permettant une mise en production rapide, un scaling automatique, et une disponibilité optimale.

\textbf{Netlify (Frontend)}

% LOGO NETLIFY
\begin{figure}[H]
    \centering
    %\includegraphics[width=3cm]{images/netlify_logo.png}
    \fbox{\parbox{3cm}{\centering\vspace{1cm}\textbf{LOGO NETLIFY}\vspace{1cm}}}
\end{figure}

Netlify est une plateforme d'hébergement spécialisée dans les sites statiques et applications JAMstack. Elle offre un déploiement automatique depuis GitHub, un CDN global, et des certificats SSL gratuits.

\vspace{0.5cm}

\textbf{Render (Backend)}

% LOGO RENDER
\begin{figure}[H]
    \centering
    %\includegraphics[width=3cm]{images/render_logo.png}
    \fbox{\parbox{3cm}{\centering\vspace{1cm}\textbf{LOGO RENDER}\vspace{1cm}}}
\end{figure}

Render est une plateforme cloud pour l'hébergement de services web, bases de données et applications. Elle supporte le déploiement automatique et la mise à l'échelle des applications Python.

\vspace{0.5cm}

\textbf{GitHub Actions}

% LOGO GITHUB ACTIONS
\begin{figure}[H]
    \centering
    %\includegraphics[width=3cm]{images/github_actions_logo.png}
    \fbox{\parbox{3cm}{\centering\vspace{1cm}\textbf{LOGO GITHUB ACTIONS}\vspace{1cm}}}
\end{figure}

GitHub Actions est utilisé pour l'intégration et le déploiement continus (CI/CD). Un workflow automatisé maintient le serveur backend actif en envoyant des requêtes périodiques.

%-------------------------------------------------------------------------------
\section{Architecture Globale}

Cette section présente l'architecture générale du système, illustrant la séparation entre le frontend et le backend, ainsi que les protocoles de communication utilisés. Cette vue d'ensemble permet de comprendre l'organisation globale du projet avant d'aborder les détails techniques dans le chapitre suivant.

Le système suit une architecture \textbf{client-serveur} avec une séparation claire entre le frontend de visualisation et le backend de simulation :

% ============================================
% ESPACE POUR DIAGRAMME D'ARCHITECTURE
% ============================================
\begin{figure}[H]
    \centering
    %\includegraphics[width=14cm]{diagrams/architecture_globale.png}
    \fbox{\parbox{14cm}{\centering\vspace{5cm}\textbf{DIAGRAMME D'ARCHITECTURE GLOBALE}\\(Frontend ↔ WebSocket ↔ Backend)\vspace{5cm}}}
    \caption{Architecture globale du système}
\end{figure}

\begin{lstlisting}[caption=Schéma d'architecture textuel]
+------------------------------------------+
|       Frontend (React + Three.js)        |
|  * Visualisation 3D                      |
|  * Interface Utilisateur                 |
|  * Physique des Vehicules                |
|  * Detection des Collisions              |
+------------------+-----------------------+
                   | WebSocket (JSON)
                   | Bidirectionnel temps reel
+------------------+-----------------------+
|       Backend (Python aiohttp)           |
|  * Generation d'etats du trafic          |
|  * Controleur de feux                    |
|  * Systeme d'evenements                  |
|  * Securite et limitation de debit       |
+------------------------------------------+
\end{lstlisting}

Le \textbf{Frontend} est responsable du rendu visuel 3D, de la physique locale des véhicules, de la détection des collisions, et de l'interface utilisateur. Il communique avec le backend via une connexion WebSocket persistante.

Le \textbf{Backend} génère les états du trafic, gère les cycles des feux de circulation, crée les véhicules, et diffuse les mises à jour à tous les clients connectés. Il implémente également les mesures de sécurité (validation d'origine, limitation de débit).

La communication utilise le protocole \textbf{WebSocket} avec des messages au format JSON, permettant des mises à jour bidirectionnelles en temps réel avec une latence minimale.

%-------------------------------------------------------------------------------
\section{Conclusion du Chapitre}

Ce deuxième chapitre a permis de définir précisément le cadre de développement du projet. Notre analyse collaborative des besoins a identifié quatre acteurs principaux (utilisateur final, serveur de simulation, client web, administrateur) et a établi sept besoins fonctionnels couvrant l'ensemble des fonctionnalités attendues : visualisation 3D, simulation des feux, physique des véhicules, événements dynamiques, interface de contrôle, communication temps réel, et détection des collisions.

Les besoins non fonctionnels garantissent la qualité du système : performance (60 FPS, latence < 200ms), sécurité (validation d'origine, rate limiting), fiabilité (100 clients simultanés, heartbeat), maintenabilité (architecture modulaire), et portabilité (compatibilité multi-navigateurs). Ces exigences constituent le cahier des charges technique du projet.

L'environnement de travail a été soigneusement sélectionné pour optimiser la productivité et la qualité du code : Visual Studio Code comme IDE, GitHub pour le contrôle de version, et un stack technologique moderne (Node.js, React, Three.js, Vite pour le frontend ; Python, aiohttp pour le backend). Les plateformes de déploiement (Netlify, Render, GitHub Actions) assurent une mise en production automatisée et fiable.

L'architecture globale client-serveur, avec communication WebSocket bidirectionnelle, a été présentée. Cette architecture garantit une séparation claire des responsabilités : le frontend gère le rendu 3D et l'interface utilisateur, tandis que le backend assure la logique métier et la diffusion des états. Cette organisation facilite la maintenance, l'évolutivité et les tests du système.

Le chapitre suivant détaillera l'implémentation concrète du système, incluant l'architecture détaillée des modules, les algorithmes clés, les mécanismes de sécurité, et le processus de déploiement en production.

%===============================================================================
% CHAPITRE 3 : RÉALISATION
%===============================================================================
\chapter{Réalisation}

Ce chapitre présente la phase d'implémentation du système, détaillant l'architecture technique, les algorithmes développés, les mécanismes de sécurité, et le déploiement en production. Il permet de comprendre comment les spécifications définies au chapitre précédent ont été concrétisées.

Ce chapitre présente en détail l'implémentation du système de simulation de feux de circulation, incluant l'architecture technique, les modules développés, et le déploiement en production.

%-------------------------------------------------------------------------------
\section{Architecture Détaillée}

Cette section approfondit l'organisation interne du système, décrivant les modules développés pour le backend et le frontend. L'architecture détaillée illustre la décomposition en composants réutilisables et la répartition des responsabilités.

\subsection{Architecture Backend}

Le backend est organisé en trois modules Python distincts, suivant le principe de séparation des responsabilités :

\begin{lstlisting}[caption=Structure des modules backend]
backend/
+-- traffic.py              # Point d'entree principal
+-- traffic_simulation.py   # Logique metier
+-- server.py               # Couche reseau
+-- .env                    # Configuration
+-- requirements.txt        # Dependances
\end{lstlisting}

\subsubsection{Module traffic.py (Point d'Entrée)}

Ce module orchestre le démarrage de l'application :

\begin{itemize}
    \item Chargement des variables d'environnement via \texttt{python-dotenv}
    \item Création des instances \texttt{TrafficSimulator} et \texttt{WebSocketServer}
    \item Gestion du cycle de vie de l'application (démarrage, arrêt gracieux)
    \item Configuration du système de logging
\end{itemize}

\subsubsection{Module traffic\_simulation.py (Logique Métier)}

Ce module contient la logique de simulation :

\textbf{TrafficLightController :} Machine à états gérant les transitions des feux de circulation. Implémente le cycle VERT (30s) → JAUNE (3s) → ROUGE avec synchronisation des paires Nord/Sud et Est/Ouest.

\textbf{TrafficSimulator :} Génère les états du trafic incluant :
\begin{itemize}
    \item Génération de véhicules (1-6 par direction par intervalle)
    \item Système d'événements pondérés (Heure de pointe, Accident, Météo, etc.)
    \item Calcul du flux de trafic basé sur les événements actifs
\end{itemize}

\subsubsection{Module server.py (Couche Réseau)}

Ce module gère toutes les opérations réseau :

\textbf{WebSocketServer :} Classe principale gérant :
\begin{itemize}
    \item Acceptation des connexions clients avec validation d'origine
    \item Limitation de débit (10 connexions/minute/IP)
    \item Diffusion des états à tous les clients connectés
    \item Heartbeat pour détecter les connexions mortes
    \item Points de terminaison HTTP (\texttt{/healthz}, \texttt{/metrics})
\end{itemize}

% ============================================
% ESPACE POUR DIAGRAMME DE SÉQUENCE
% ============================================
\begin{figure}[H]
    \centering
    %\includegraphics[width=14cm]{diagrams/diagramme_sequence.png}
    \fbox{\parbox{14cm}{\centering\vspace{5cm}\textbf{DIAGRAMME DE SÉQUENCE}\\(Flux de communication Client-Serveur)\vspace{5cm}}}
    \caption{Diagramme de séquence de la communication}
\end{figure}

\subsection{Architecture Frontend}

Le frontend React suit une architecture modulaire basée sur les composants :

\begin{lstlisting}[caption=Structure des fichiers frontend]
src/
+-- ThreeScene.jsx          # Orchestrateur principal
+-- main.jsx                # Point d'entree React
+-- utils/
|   +-- Constants.js        # Configuration centralisee
|   +-- TurnHelpers.js      # Calculs geometriques
+-- scene/
|   +-- MapBuilders.js      # Generation des cartes 3D
|   +-- TrafficLights.js    # Rendu des feux
|   +-- VehiclePhysics.js   # Moteur physique
+-- components/
    +-- HUD.jsx             # Interface utilisateur
    +-- LoadingScreen.jsx   # Ecran de chargement
    +-- MapSidebar.jsx      # Selection de carte
\end{lstlisting}

\subsubsection{ThreeScene.jsx (Orchestrateur Principal)}

Composant React central qui :
\begin{itemize}
    \item Initialise la scène Three.js (caméra, lumières, renderer)
    \item Gère la connexion WebSocket avec le backend
    \item Coordonne la boucle d'animation (60 FPS)
    \item Maintient l'état global de la simulation via React Refs
\end{itemize}

\subsubsection{Modules Scene}

\textbf{MapBuilders.js :} Génère les différents environnements 3D (intersection simple, pluie, désert, neige, grille urbaine) avec routes, textures et éclairages spécifiques.

\textbf{TrafficLights.js :} Construit les feux de circulation 3D avec poteaux, boîtiers, ampoules colorées et affichages de minuterie basés sur canvas.

\textbf{VehiclePhysics.js :} Implémente le moteur physique des véhicules incluant :
\begin{itemize}
    \item Machine à états des virages (STRAIGHT, ENTERING, ROTATING, EXITING)
    \item Logique d'arrêt aux feux rouges
    \item Maintien des distances de sécurité
    \item Détection des collisions
\end{itemize}

\subsubsection{Composants UI}

\textbf{HUD.jsx :} Affiche les informations en temps réel (statut de connexion, bouton pause, compteur de collisions, événements actifs).

\textbf{LoadingScreen.jsx :} Écran de transition lors du changement de carte avec barre de progression.

\textbf{MapSidebar.jsx :} Barre latérale permettant de sélectionner parmi les 5 environnements disponibles.

% ============================================
% ESPACE POUR DIAGRAMME DE COMPOSANTS
% ============================================
\begin{figure}[H]
    \centering
    %\includegraphics[width=14cm]{diagrams/architecture_frontend.png}
    \fbox{\parbox{14cm}{\centering\vspace{5cm}\textbf{DIAGRAMME DE COMPOSANTS FRONTEND}\\(Hiérarchie des composants React)\vspace{5cm}}}
    \caption{Diagramme des composants frontend}
\end{figure}

%-------------------------------------------------------------------------------
\section{Implémentation des Fonctionnalités Clés}

Cette section présente les algorithmes et mécanismes techniques implémentés pour les fonctionnalités essentielles du système : gestion des feux de circulation, physique des virages, synchronisation temporelle, et protocole de communication.

\subsection{Machine à États des Feux de Circulation}

Le contrôleur de feux implémente une machine à états synchronisée pour les paires de directions :

\begin{lstlisting}[language=Python, caption=Logique de transition des feux]
def _check_transition(self):
    # Paire Nord/Sud
    if self.timers['N'] <= 0:
        if self.lights['N'] == 'GREEN':
            # Transition de securite
            self.lights['N'] = self.lights['S'] = 'YELLOW'
            self.timers['N'] = self.timers['S'] = 3.0
        elif self.lights['N'] == 'YELLOW':
            # Basculer vers Est/Ouest
            self.lights['N'] = self.lights['S'] = 'RED'
            self.lights['E'] = self.lights['W'] = 'GREEN'
            self.timers['E'] = self.timers['W'] = 30.0
\end{lstlisting}

\subsection{Physique des Virages}

Le système de virages utilise une machine à états à 4 phases pour des trajectoires réalistes :

\begin{enumerate}
    \item \textbf{STRAIGHT} : Mouvement rectiligne, détection de la zone de virage
    \item \textbf{ENTERING\_TURN} (2 unités) : Approche progressive de l'arc
    \item \textbf{ROTATING} (9,54 unités) : Rotation de 90° avec trajectoire courbe
    \item \textbf{EXITING\_TURN} (2 unités) : Redressement dans la nouvelle direction
\end{enumerate}

\begin{lstlisting}[language=JavaScript, caption=Calcul de la trajectoire courbe]
// Interpolation pour virage a droite
const easedProgress = Math.sin(turnProgress * Math.PI / 2);
const blendedX = currentDir * (1.5 - progress) + newDir * progress;

// Virage a gauche avec poussee laterale
const lateralPush = Math.sin(progress * Math.PI) * 0.4;
\end{lstlisting}

\subsection{Synchronisation Temporelle}

Pour assurer des minuteries fluides malgré la latence réseau, le système utilise une synchronisation basée sur les horodatages :

\begin{lstlisting}[language=JavaScript, caption=Interpolation des minuteries]
// Le serveur envoie ExpiresAt (timestamp absolu)
const estimatedServerNow = lastServerTime + (performance.now() - lastPacketTime);
const remainingMs = light.ExpiresAt - estimatedServerNow;
const remainingSec = Math.max(0, remainingMs / 1000);
\end{lstlisting}

\subsection{Protocole de Communication}

Les messages WebSocket suivent un format JSON structuré :

\begin{lstlisting}[language=json, caption=Format des messages serveur vers client]
{
  "Lights": [
    {"Sens": "N", "Couleur": "GREEN", "Timer": 27.3, 
     "ExpiresAt": 1737486156234}
  ],
  "Vehicles": [
    {"Id": 142, "Sens": "N", "Voie": "Lane1", 
     "Position": 15.2, "Speed": 12.4}
  ],
  "Event": {"name": "Rush Hour", "flow_mult": 1.8},
  "ServerTime": 1737486129234,
  "Reset": true
}
\end{lstlisting}

%-------------------------------------------------------------------------------
\section{Sécurité et Performance}

La mise en production d'une application web nécessite la mise en place de mesures de sécurité robustes et d'optimisations de performance. Cette section détaille les mécanismes implémentés pour protéger le système contre les attaques et garantir une expérience utilisateur fluide.

\subsection{Mesures de Sécurité}

\subsubsection{Validation d'Origine}

Seules les connexions provenant de domaines autorisés sont acceptées :

\begin{lstlisting}[language=Python, caption=Validation des origines]
ALLOWED_ORIGINS = [
    'https://iteam-traffic-light.netlify.app',
    'http://localhost:5173',
    'http://localhost:5174'
]

def validate_origin(request, allowed_origins):
    origin = request.headers.get('Origin', '')
    return origin in allowed_origins
\end{lstlisting}

\subsubsection{Limitation de Débit}

Protection contre les abus avec fenêtre glissante :

\begin{lstlisting}[language=Python, caption=Rate limiting]
def check_rate_limit(client_ip, window=60, max_connections=10):
    now = time.time()
    # Nettoyer les timestamps expires
    rate_limit_store[client_ip] = [
        ts for ts in rate_limit_store.get(client_ip, [])
        if now - ts < window
    ]
    if len(rate_limit_store[client_ip]) >= max_connections:
        return False  # Limite atteinte
    rate_limit_store[client_ip].append(now)
    return True
\end{lstlisting}

\subsection{Optimisations de Performance}

\begin{itemize}
    \item \textbf{Réutilisation de géométrie} : Les meshes des véhicules partagent une géométrie commune
    \item \textbf{Mise à jour sélective} : Seuls les changements d'état sont diffusés
    \item \textbf{Throttling des canvas} : Les minuteries ne sont redessinées que toutes les 250ms
    \item \textbf{Delta time} : La physique utilise le temps écoulé pour une cohérence indépendante du FPS
\end{itemize}

%-------------------------------------------------------------------------------
\section{Déploiement}

Le déploiement en production constitue l'étape finale du projet. Cette section décrit l'infrastructure cloud sélectionnée, les configurations de déploiement pour le frontend et le backend, le workflow CI/CD automatisé, et les mécanismes de monitoring mis en place.

\subsection{Infrastructure de Déploiement}

Le système est déployé sur deux plateformes cloud complémentaires :

% ============================================
% ESPACE POUR DIAGRAMME DE DÉPLOIEMENT
% ============================================
\begin{figure}[H]
    \centering
    %\includegraphics[width=14cm]{diagrams/diagramme_deploiement.png}
    \fbox{\parbox{14cm}{\centering\vspace{5cm}\textbf{DIAGRAMME DE DÉPLOIEMENT}\\(Netlify + Render + GitHub Actions)\vspace{5cm}}}
    \caption{Architecture de déploiement}
\end{figure}

\subsection{Déploiement Frontend sur Netlify}

Le frontend React est hébergé sur Netlify avec les configurations suivantes :

\begin{lstlisting}[caption=Configuration netlify.toml]
[build]
  command = "npm run build"
  publish = "dist"

[[redirects]]
  from = "/*"
  to = "/index.html"
  status = 200
\end{lstlisting}

% ============================================
% ESPACE POUR CAPTURE NETLIFY
% ============================================
\begin{figure}[H]
    \centering
    %\includegraphics[width=14cm]{screenshots/netlify_dashboard.png}
    \fbox{\parbox{14cm}{\centering\vspace{4cm}\textbf{CAPTURE D'ÉCRAN}\\Configuration Netlify Dashboard\vspace{4cm}}}
    \caption{Interface de configuration Netlify}
\end{figure}

\textbf{Avantages de Netlify :}
\begin{itemize}
    \item Déploiement automatique depuis GitHub à chaque push
    \item CDN global pour des temps de chargement optimaux
    \item Certificat SSL/TLS automatique et gratuit
    \item Preview des branches pour les tests
\end{itemize}

\textbf{URL de production :} \url{https://iteam-traffic-light.netlify.app}

\subsection{Déploiement Backend sur Render}

Le serveur Python est hébergé sur Render.com :

\begin{lstlisting}[caption=Configuration du service Render]
# Type: Web Service
# Environment: Python 3.12
# Build Command: pip install -r requirements.txt
# Start Command: python traffic.py

# Variables d'environnement
PORT=10000
ALLOWED_ORIGINS=https://iteam-traffic-light.netlify.app
MAX_CLIENTS=100
\end{lstlisting}

\textbf{Avantages de Render :}
\begin{itemize}
    \item Support natif de Python et des WebSockets
    \item Déploiement automatique depuis GitHub
    \item Logs en temps réel pour le debugging
    \item Scaling automatique selon la charge
\end{itemize}

\textbf{URL de production :} \url{https://traffic-light-ugoe.onrender.com}

\subsection{Maintien du Serveur avec GitHub Actions}

Les services gratuits de Render mettent en veille les applications inactives après 15 minutes. Pour maintenir le serveur actif, un workflow GitHub Actions envoie des requêtes périodiques :

\begin{lstlisting}[caption=Workflow GitHub Actions (.github/workflows/keep-alive.yml)]
name: Keep Alive

on:
  schedule:
    - cron: '*/14 * * * *'  # Toutes les 14 minutes
  workflow_dispatch:

jobs:
  ping:
    runs-on: ubuntu-latest
    steps:
      - name: Ping Backend
        run: |
          curl -X GET https://traffic-light-ugoe.onrender.com/healthz
          echo "Backend pinged successfully"
\end{lstlisting}

\textbf{Fonctionnement :}
\begin{enumerate}
    \item GitHub Actions exécute le workflow toutes les 14 minutes
    \item Une requête HTTP GET est envoyée au endpoint \texttt{/healthz}
    \item Le serveur répond "OK", confirmant qu'il est actif
    \item Si le serveur était en veille, la requête le réveille
\end{enumerate}

\subsection{Points de Terminaison de Monitoring}

Le backend expose des endpoints pour le monitoring :

\begin{lstlisting}[language=Python, caption=Endpoints de monitoring]
# Health Check
@routes.get('/healthz')
async def healthz(request):
    return web.Response(text="OK")

# Metriques
@routes.get('/metrics')
async def metrics(request):
    return web.json_response({
        "connected_clients": len(clients),
        "max_clients": MAX_CLIENTS,
        "uptime_intervals": interval_count,
        "rate_limited_ips": len(rate_limit_store)
    })
\end{lstlisting}

%-------------------------------------------------------------------------------
\section{Captures d'Écran}

Cette section présente des captures d'écran de l'application en fonctionnement, illustrant l'interface utilisateur, les différents environnements de simulation, et les éléments interactifs du système.

\subsection{Interface Principale}

% ============================================
% CAPTURE D'ÉCRAN - INTERFACE PRINCIPALE
% ============================================
\begin{figure}[H]
    \centering
    %\includegraphics[width=14cm]{screenshots/interface_principale.png}
    \fbox{\parbox{14cm}{\centering\vspace{6cm}\textbf{CAPTURE D'ÉCRAN}\\Interface principale avec intersection 3D\vspace{6cm}}}
    \caption{Interface principale de la simulation}
\end{figure}

\subsection{Différents Environnements de Carte}

% ============================================
% CAPTURES D'ÉCRAN - ENVIRONNEMENTS
% ============================================
\begin{figure}[H]
    \centering
    \begin{minipage}{0.45\textwidth}
        \centering
        %\includegraphics[width=5.5cm]{screenshots/intersection_pluie.png}
        \fbox{\parbox{5.5cm}{\centering\vspace{3cm}\textbf{INTERSECTION PLUVIEUSE}\vspace{3cm}}}
    \end{minipage}
    \hfill
    \begin{minipage}{0.45\textwidth}
        \centering
        %\includegraphics[width=5.5cm]{screenshots/intersection_desert.png}
        \fbox{\parbox{5.5cm}{\centering\vspace{3cm}\textbf{INTERSECTION DÉSERTIQUE}\vspace{3cm}}}
    \end{minipage}
    \caption{Environnements thématiques : pluie et désert}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{minipage}{0.45\textwidth}
        \centering
        %\includegraphics[width=5.5cm]{screenshots/intersection_neige.png}
        \fbox{\parbox{5.5cm}{\centering\vspace{3cm}\textbf{INTERSECTION ENNEIGÉE}\vspace{3cm}}}
    \end{minipage}
    \hfill
    \begin{minipage}{0.45\textwidth}
        \centering
        %\includegraphics[width=5.5cm]{screenshots/grille_urbaine.png}
        \fbox{\parbox{5.5cm}{\centering\vspace{3cm}\textbf{GRILLE URBAINE}\vspace{3cm}}}
    \end{minipage}
    \caption{Environnements thématiques : neige et ville}
\end{figure}

\subsection{Interface Utilisateur (HUD)}

% ============================================
% CAPTURE D'ÉCRAN - HUD
% ============================================
\begin{figure}[H]
    \centering
    %\includegraphics[width=14cm]{screenshots/hud_interface.png}
    \fbox{\parbox{14cm}{\centering\vspace{4cm}\textbf{CAPTURE D'ÉCRAN}\\Éléments du HUD (statut connexion, pause, collisions, événements)\vspace{4cm}}}
    \caption{Éléments de l'interface utilisateur}
\end{figure}

\subsection{Barre Latérale de Sélection de Carte}

% ============================================
% CAPTURE D'ÉCRAN - SIDEBAR
% ============================================
\begin{figure}[H]
    \centering
    %\includegraphics[width=8cm]{screenshots/map_sidebar.png}
    \fbox{\parbox{8cm}{\centering\vspace{5cm}\textbf{CAPTURE D'ÉCRAN}\\Barre latérale de sélection de carte\vspace{5cm}}}
    \caption{Sélecteur de carte avec les 5 environnements}
\end{figure}

%-------------------------------------------------------------------------------
\section{Tests et Validation}

La phase de tests est essentielle pour valider le bon fonctionnement du système et garantir sa qualité. Cette section présente les tests fonctionnels, de performance et de sécurité réalisés pour s'assurer de la conformité du système aux spécifications.

\subsection{Tests Fonctionnels}

Les fonctionnalités suivantes ont été validées :

\begin{table}[H]
\centering
\caption{Résultats des tests fonctionnels}
\begin{tblr}{
    colspec = {|X[2]|c|X|},
    hlines,
    row{1} = {bg=primaryblue, fg=white, font=\bfseries},
}
Fonctionnalité & Statut & Observations \\
Connexion WebSocket & \checkmark & Connexion établie en moins de 1 seconde \\
Rendu 3D de l'intersection & \checkmark & 60 FPS stable sur navigateurs modernes \\
Cycle des feux de circulation & \checkmark & Transitions correctes VERT→JAUNE→ROUGE \\
Mouvement des véhicules & \checkmark & Physique réaliste avec virages fluides \\
Arrêt aux feux rouges & \checkmark & Décélération progressive avant la ligne \\
Détection des collisions & \checkmark & Compteur incrémenté correctement \\
Changement de carte & \checkmark & Transition fluide avec écran de chargement \\
Pause/Reprise & \checkmark & État préservé pendant la pause \\
Reconnexion automatique & \checkmark & Reconnexion après perte de connexion \\
\end{tblr}
\end{table}

\subsection{Tests de Performance}

\begin{itemize}
    \item \textbf{Rendu} : 60 FPS stable avec 50+ véhicules simultanés
    \item \textbf{Latence} : Mises à jour reçues en moins de 100ms en moyenne
    \item \textbf{Charge} : Support testé avec 20 clients simultanés sans dégradation
    \item \textbf{Mémoire} : Pas de fuite mémoire détectée après 1 heure d'utilisation
\end{itemize}

\subsection{Tests de Sécurité}

\begin{itemize}
    \item \textbf{Validation d'origine} : Connexions depuis domaines non autorisés rejetées (403)
    \item \textbf{Limitation de débit} : 11ème connexion en 1 minute rejetée (429)
    \item \textbf{Limite de taille} : Messages de plus de 1 Ko ignorés
\end{itemize}

%-------------------------------------------------------------------------------
\section{Conclusion du Chapitre}

Ce troisième chapitre a détaillé l'implémentation complète du système de simulation de feux de circulation. L'architecture technique, organisée en modules distincts et réutilisables, garantit une maintenabilité optimale. Le backend Python comprend trois modules (traffic.py, traffic\_simulation.py, server.py) gérant respectivement l'orchestration, la logique métier, et la couche réseau. Le frontend React repose sur une architecture modulaire avec séparation des responsabilités : orchestration (ThreeScene.jsx), rendu 3D (MapBuilders, TrafficLights, VehiclePhysics), et interface utilisateur (HUD, LoadingScreen, MapSidebar).

Les fonctionnalités clés ont été implémentées avec des algorithmes robustes : machine à états pour les feux de circulation, système de virages en 4 phases pour des trajectoires réalistes, synchronisation temporelle basée sur les horodatages absolus, et protocole WebSocket JSON structuré. Ces implémentations garantissent un comportement fluide et réaliste de la simulation.

Les mesures de sécurité (validation d'origine, limitation de débit, restriction de taille) et les optimisations de performance (réutilisation de géométrie, mises à jour sélectives, throttling) assurent un système robuste et performant. Le déploiement sur Netlify et Render, avec automatisation via GitHub Actions, garantit une disponibilité continue et une mise en production simplifiée.

Les captures d'écran illustrent l'interface utilisateur aboutie et les différents environnements thématiques. Les tests fonctionnels, de performance et de sécurité valident la conformité du système aux spécifications : 60 FPS stables, latence < 100ms, support de 20 clients simultanés, et protection efficace contre les attaques.

Le système développé par notre binôme répond pleinement aux objectifs fixés en début de projet : accessibilité web, visualisation 3D interactive, architecture distribuée moderne, communication temps réel, et déploiement en production. Les compétences acquises durant ce projet collaboratif (développement full-stack, programmation asynchrone, rendu 3D, déploiement cloud, travail d'équipe) constituent un atout majeur pour la suite de notre parcours académique et professionnel.

%===============================================================================
% CONCLUSION GÉNÉRALE ET PERSPECTIVES
%===============================================================================
\chapter*{Conclusion Générale et Perspectives}
\addcontentsline{toc}{chapter}{Conclusion Générale et Perspectives}

Ce projet semestriel en binôme, réalisé dans le cadre du module \textbf{[Nom du Module]} enseigné par \textbf{[Nom du Professeur]} à \textbf{[Nom de l'Université]}, a permis de concevoir et développer un système complet de simulation de feux de circulation avec visualisation 3D en temps réel. L'application développée par notre équipe combine les technologies web modernes (React 18, Three.js r160) avec un backend Python asynchrone (aiohttp 3.9) pour offrir une expérience utilisateur fluide, interactive et immersive.

\section*{Synthèse des Réalisations}

Le travail accompli par notre binôme durant ce projet s'articule autour de trois phases principales, correspondant aux trois chapitres de ce rapport. L'analyse et conception ont permis d'identifier les limitations des solutions existantes et de proposer une architecture web moderne. Le développement collaboratif et l'implémentation ont abouti à un système modulaire robuste avec communication temps réel via WebSocket. Le déploiement et la validation ont confirmé la conformité du système aux spécifications avec des performances optimales.

\section*{Objectifs Atteints}

L'ensemble des objectifs fixés en début de projet ont été atteints :
\begin{itemize}
    \item Architecture client-serveur modulaire avec séparation claire des responsabilités
    \item Communication temps réel via WebSocket avec synchronisation temporelle basée sur horodatages absolus
    \item Visualisation 3D interactive avec 5 environnements thématiques et contrôle de caméra intuitif
    \item Physique réaliste des véhicules avec machine à états pour les virages et détection des collisions
    \item Mesures de sécurité en production (validation d'origine, limitation de débit, restriction de taille)
    \item Déploiement automatisé sur Netlify et Render avec workflow GitHub Actions
    \item Système d'événements dynamiques simulant divers scénarios de trafic réalistes
\end{itemize}

\section*{Compétences Développées}

Ce projet en binôme a permis d'acquérir et d'approfondir des compétences techniques et collaboratives essentielles :
\begin{itemize}
    \item Développement full-stack en équipe (JavaScript/React, Python/aiohttp) et architectures distribuées
    \item Programmation asynchrone (async/await), gestion d'événements et protocole WebSocket
    \item Rendu 3D temps réel avec Three.js, manipulation de géométries et optimisation WebGL
    \item Conception logicielle (machines à états, architecture modulaire, patterns de conception)
    \item Sécurité informatique (validation d'entrées, protection DoS, gestion sécurisée des connexions)
    \item Déploiement et DevOps (plateformes cloud, automatisation CI/CD, monitoring)
    \item Gestion de projet collaboratif (analyse des besoins, planification, documentation, tests et validation)
    \item Travail d'équipe (répartition des tâches, communication, résolution collaborative de problèmes)
\end{itemize}

\section*{Difficultés Rencontrées et Solutions Apportées}

Durant le développement, notre équipe a identifié et résolu plusieurs défis techniques :
\begin{enumerate}
    \item \textbf{Synchronisation temporelle :} Résolu par l'utilisation d'horodatages absolus (ExpiresAt) avec interpolation côté client basée sur le temps écoulé
    \item \textbf{Trajectoires réalistes :} Implémenté via machine à états à 4 phases (STRAIGHT, ENTERING\_TURN, ROTATING, EXITING\_TURN) avec trajectoires courbes
    \item \textbf{Mise en veille du serveur :} Contourné grâce à GitHub Actions envoyant des requêtes périodiques (toutes les 14 minutes) au endpoint /healthz
    \item \textbf{Performance du rendu :} Optimisé par réutilisation des géométries, mises à jour sélectives et throttling du redessin des canvas
\end{enumerate}

\section*{Perspectives d'Évolution}

Ce projet constitue une base solide pour de nombreuses évolutions futures :

\subsection*{Évolutions Fonctionnelles}
\begin{itemize}
    \item Nouveaux types d'intersections (carrefours giratoires, passages piétons, sens uniques)
    \item Piétons et vélos avec comportements spécifiques
    \item Transports en commun (bus, tramways) avec arrêts programmés
    \item Conditions météorologiques dynamiques affectant la circulation
    \item Statistiques avancées (temps d'attente, débit par voie, graphiques temps réel)
\end{itemize}

\subsection*{Évolutions Techniques}
\begin{itemize}
    \item Optimisation automatique des cycles de feux par apprentissage automatique
    \item Intégration de données réelles (OpenStreetMap, API de trafic)
    \item Mode collaboratif permettant le contrôle manuel multi-utilisateurs
    \item Export de données (rapports PDF, statistiques CSV, enregistrements vidéo)
    \item Application mobile (React Native) avec adaptation tactile
    \item Intelligence artificielle (apprentissage par renforcement pour comportements réalistes)
\end{itemize}

\subsection*{Amélioration de l'Infrastructure}
\begin{itemize}
    \item Base de données pour stockage des sessions et historique
    \item Authentification avec profils utilisateurs et préférences sauvegardées
    \item API REST pour intégration avec systèmes externes
    \item Monitoring avancé (Prometheus, Grafana) et alertes automatiques
    \item Tests automatisés (unitaires, intégration) avec couverture de code complète
\end{itemize}

\section*{Conclusion}

Ce projet démontre qu'il est possible de créer une application web complexe, performante et sécurisée, en combinant judicieusement les technologies frontend et backend modernes. L'architecture développée offre une base solide pour des évolutions futures tout en garantissant maintenabilité et scalabilité.

Au-delà des aspects techniques, ce projet en binôme a représenté une opportunité précieuse de mettre en pratique une démarche d'ingénierie logicielle complète en équipe. Les compétences techniques et collaboratives acquises constituent un atout majeur pour la poursuite de notre parcours académique et professionnel dans le domaine du développement logiciel.

Enfin, ce projet illustre l'importance d'une approche méthodique et rigoureuse dans le développement d'applications web modernes, où la collaboration en équipe, la séparation des responsabilités, la sécurité, et la performance doivent être intégrées dès la conception pour garantir la qualité du produit final.

\newpage

%===============================================================================
% RÉFÉRENCES
%===============================================================================
\chapter*{Références}
\addcontentsline{toc}{chapter}{Références}

\section*{Documentation Technique}

\begin{enumerate}
    \item \textbf{React Documentation} - \url{https://react.dev/} \\  
    Documentation officielle de React 18, hooks et composants
    
    \item \textbf{Three.js Documentation} - \url{https://threejs.org/docs/} \\  
    Documentation officielle de Three.js r160, exemples et API
    
    \item \textbf{Vite Guide} - \url{https://vitejs.dev/guide/} \\  
    Guide officiel de Vite 5, configuration et optimisations
    
    \item \textbf{Python aiohttp Documentation} - \url{https://docs.aiohttp.org/} \\  
    Documentation de aiohttp 3.9, WebSocket et programmation asynchrone
    
    \item \textbf{MDN Web Docs - WebSocket API} \\
    \url{https://developer.mozilla.org/en-US/docs/Web/API/WebSocket} \\  
    Spécification et exemples du protocole WebSocket
    
    \item \textbf{WebGL Fundamentals} - \url{https://webglfundamentals.org/} \\  
    Fondamentaux du rendu 3D avec WebGL
\end{enumerate}

\section*{Plateformes de Déploiement}

\begin{enumerate}
    \item \textbf{Netlify Documentation} - \url{https://docs.netlify.com/} \\  
    Déploiement et configuration de sites statiques
    
    \item \textbf{Render Documentation} - \url{https://render.com/docs} \\  
    Hébergement de services web Python
    
    \item \textbf{GitHub Actions Documentation} - \url{https://docs.github.com/en/actions} \\  
    Workflows CI/CD et automatisation
\end{enumerate}

\section*{Outils de Simulation de Trafic (État de l'Art)}

\begin{enumerate}
    \item \textbf{SUMO - Simulation of Urban MObility} \\
    \url{https://www.eclipse.org/sumo/} \\  
    Simulateur de trafic microscopique open source, DLR
    
    \item \textbf{PTV Vissim} - \url{https://www.ptvgroup.com/en/products/ptv-vissim} \\  
    Logiciel commercial de microsimulation du trafic
    
    \item \textbf{AnyLogic Road Traffic Library} \\
    \url{https://www.anylogic.com/road-traffic-library/} \\  
    Bibliothèque de simulation multi-méthodes pour le trafic
\end{enumerate}

\section*{Articles et Standards}

\begin{enumerate}
    \item \textbf{RFC 6455 - The WebSocket Protocol} \\
    \url{https://datatracker.ietf.org/doc/html/rfc6455} \\  
    Spécification officielle du protocole WebSocket
    
    \item \textbf{JSON Specification} - \url{https://www.json.org/} \\  
    Format d'échange de données structurées
    
    \item \textbf{OpenStreetMap} - \url{https://www.openstreetmap.org/} \\  
    Données cartographiques libres et collaboratives
\end{enumerate}

\section*{Code Source du Projet}

\begin{itemize}
    \item \textbf{Repository GitHub} \\
    \url{https://github.com/Yassine-Frigui/Traffic-light} \\  
    Code source complet du projet, branches et historique
    
    \item \textbf{Frontend déployé} \\
    \url{https://iteam-traffic-light.netlify.app} \\  
    Application React en production sur Netlify
    
    \item \textbf{Backend déployé} \\
    \url{https://traffic-light-ugoe.onrender.com} \\  
    Serveur Python en production sur Render
\end{itemize}

%===============================================================================
% ANNEXES
%===============================================================================
\appendix
\chapter{Annexes}

\section{Code Source}

Le code source complet du projet est disponible sur GitHub :

\url{https://github.com/Yassine-Frigui/Traffic-light}

\section{Liens de Déploiement}

\begin{itemize}
    \item \textbf{Frontend} : \url{https://iteam-traffic-light.netlify.app}
    \item \textbf{Backend} : \url{https://traffic-light-ugoe.onrender.com}
\end{itemize}

\section{Statistiques du Projet}

\begin{table}[H]
\centering
\caption{Statistiques du projet}
\begin{tblr}{
    colspec = {|l|r|},
    hlines,
    row{1} = {bg=primaryblue, fg=white, font=\bfseries},
}
Métrique & Valeur \\
Lignes de code totales & $\sim$3,500 \\
Modules Frontend & 12 fichiers \\
Modules Backend & 3 fichiers \\
Types de cartes & 5 environnements \\
Types d'événements & 6 scénarios \\
Taux de rafraîchissement & 60 FPS (rendu) \\
Fréquence de mise à jour & 10 updates/sec (physique) \\
\end{tblr}
\end{table}

\end{document}
